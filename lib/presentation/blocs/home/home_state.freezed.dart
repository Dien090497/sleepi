// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'home_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$HomeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)
        loaded,
    required TResult Function(String message) startError,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)?
        loaded,
    TResult Function(String message)? startError,
    TResult Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)?
        loaded,
    TResult Function(String message)? startError,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HomeInitial value) initial,
    required TResult Function(HomeLoading value) loading,
    required TResult Function(HomeLoaded value) loaded,
    required TResult Function(HomeStartError value) startError,
    required TResult Function(HomeError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(HomeInitial value)? initial,
    TResult Function(HomeLoading value)? loading,
    TResult Function(HomeLoaded value)? loaded,
    TResult Function(HomeStartError value)? startError,
    TResult Function(HomeError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HomeInitial value)? initial,
    TResult Function(HomeLoading value)? loading,
    TResult Function(HomeLoaded value)? loaded,
    TResult Function(HomeStartError value)? startError,
    TResult Function(HomeError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HomeStateCopyWith<$Res> {
  factory $HomeStateCopyWith(HomeState value, $Res Function(HomeState) then) =
      _$HomeStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$HomeStateCopyWithImpl<$Res> implements $HomeStateCopyWith<$Res> {
  _$HomeStateCopyWithImpl(this._value, this._then);

  final HomeState _value;
  // ignore: unused_field
  final $Res Function(HomeState) _then;
}

/// @nodoc
abstract class _$$HomeInitialCopyWith<$Res> {
  factory _$$HomeInitialCopyWith(
          _$HomeInitial value, $Res Function(_$HomeInitial) then) =
      __$$HomeInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HomeInitialCopyWithImpl<$Res> extends _$HomeStateCopyWithImpl<$Res>
    implements _$$HomeInitialCopyWith<$Res> {
  __$$HomeInitialCopyWithImpl(
      _$HomeInitial _value, $Res Function(_$HomeInitial) _then)
      : super(_value, (v) => _then(v as _$HomeInitial));

  @override
  _$HomeInitial get _value => super._value as _$HomeInitial;
}

/// @nodoc

class _$HomeInitial with DiagnosticableTreeMixin implements HomeInitial {
  const _$HomeInitial();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.initial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'HomeState.initial'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$HomeInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)
        loaded,
    required TResult Function(String message) startError,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)?
        loaded,
    TResult Function(String message)? startError,
    TResult Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)?
        loaded,
    TResult Function(String message)? startError,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HomeInitial value) initial,
    required TResult Function(HomeLoading value) loading,
    required TResult Function(HomeLoaded value) loaded,
    required TResult Function(HomeStartError value) startError,
    required TResult Function(HomeError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(HomeInitial value)? initial,
    TResult Function(HomeLoading value)? loading,
    TResult Function(HomeLoaded value)? loaded,
    TResult Function(HomeStartError value)? startError,
    TResult Function(HomeError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HomeInitial value)? initial,
    TResult Function(HomeLoading value)? loading,
    TResult Function(HomeLoaded value)? loaded,
    TResult Function(HomeStartError value)? startError,
    TResult Function(HomeError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class HomeInitial implements HomeState {
  const factory HomeInitial() = _$HomeInitial;
}

/// @nodoc
abstract class _$$HomeLoadingCopyWith<$Res> {
  factory _$$HomeLoadingCopyWith(
          _$HomeLoading value, $Res Function(_$HomeLoading) then) =
      __$$HomeLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HomeLoadingCopyWithImpl<$Res> extends _$HomeStateCopyWithImpl<$Res>
    implements _$$HomeLoadingCopyWith<$Res> {
  __$$HomeLoadingCopyWithImpl(
      _$HomeLoading _value, $Res Function(_$HomeLoading) _then)
      : super(_value, (v) => _then(v as _$HomeLoading));

  @override
  _$HomeLoading get _value => super._value as _$HomeLoading;
}

/// @nodoc

class _$HomeLoading with DiagnosticableTreeMixin implements HomeLoading {
  const _$HomeLoading();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.loading()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'HomeState.loading'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$HomeLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)
        loaded,
    required TResult Function(String message) startError,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)?
        loaded,
    TResult Function(String message)? startError,
    TResult Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)?
        loaded,
    TResult Function(String message)? startError,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HomeInitial value) initial,
    required TResult Function(HomeLoading value) loading,
    required TResult Function(HomeLoaded value) loaded,
    required TResult Function(HomeStartError value) startError,
    required TResult Function(HomeError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(HomeInitial value)? initial,
    TResult Function(HomeLoading value)? loading,
    TResult Function(HomeLoaded value)? loaded,
    TResult Function(HomeStartError value)? startError,
    TResult Function(HomeError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HomeInitial value)? initial,
    TResult Function(HomeLoading value)? loading,
    TResult Function(HomeLoaded value)? loaded,
    TResult Function(HomeStartError value)? startError,
    TResult Function(HomeError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class HomeLoading implements HomeState {
  const factory HomeLoading() = _$HomeLoading;
}

/// @nodoc
abstract class _$$HomeLoadedCopyWith<$Res> {
  factory _$$HomeLoadedCopyWith(
          _$HomeLoaded value, $Res Function(_$HomeLoaded) then) =
      __$$HomeLoadedCopyWithImpl<$Res>;
  $Res call(
      {List<BedEntity> bedList,
      BedEntity? selectedBed,
      BedEntity? item,
      ItemEntity? selectedItem,
      String errorMessage,
      ErrorType errorType,
      bool loadMoreBed,
      bool loading,
      bool enableInsurance,
      bool enableAlarm,
      double tokenEarn,
      bool startTracking,
      UserStatusTrackingModel? userStatusTracking,
      int hour,
      int minute,
      int time});

  $BedEntityCopyWith<$Res>? get selectedBed;
  $BedEntityCopyWith<$Res>? get item;
  $ItemEntityCopyWith<$Res>? get selectedItem;
}

/// @nodoc
class __$$HomeLoadedCopyWithImpl<$Res> extends _$HomeStateCopyWithImpl<$Res>
    implements _$$HomeLoadedCopyWith<$Res> {
  __$$HomeLoadedCopyWithImpl(
      _$HomeLoaded _value, $Res Function(_$HomeLoaded) _then)
      : super(_value, (v) => _then(v as _$HomeLoaded));

  @override
  _$HomeLoaded get _value => super._value as _$HomeLoaded;

  @override
  $Res call({
    Object? bedList = freezed,
    Object? selectedBed = freezed,
    Object? item = freezed,
    Object? selectedItem = freezed,
    Object? errorMessage = freezed,
    Object? errorType = freezed,
    Object? loadMoreBed = freezed,
    Object? loading = freezed,
    Object? enableInsurance = freezed,
    Object? enableAlarm = freezed,
    Object? tokenEarn = freezed,
    Object? startTracking = freezed,
    Object? userStatusTracking = freezed,
    Object? hour = freezed,
    Object? minute = freezed,
    Object? time = freezed,
  }) {
    return _then(_$HomeLoaded(
      bedList: bedList == freezed
          ? _value._bedList
          : bedList // ignore: cast_nullable_to_non_nullable
              as List<BedEntity>,
      selectedBed: selectedBed == freezed
          ? _value.selectedBed
          : selectedBed // ignore: cast_nullable_to_non_nullable
              as BedEntity?,
      item: item == freezed
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as BedEntity?,
      selectedItem: selectedItem == freezed
          ? _value.selectedItem
          : selectedItem // ignore: cast_nullable_to_non_nullable
              as ItemEntity?,
      errorMessage: errorMessage == freezed
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
      errorType: errorType == freezed
          ? _value.errorType
          : errorType // ignore: cast_nullable_to_non_nullable
              as ErrorType,
      loadMoreBed: loadMoreBed == freezed
          ? _value.loadMoreBed
          : loadMoreBed // ignore: cast_nullable_to_non_nullable
              as bool,
      loading: loading == freezed
          ? _value.loading
          : loading // ignore: cast_nullable_to_non_nullable
              as bool,
      enableInsurance: enableInsurance == freezed
          ? _value.enableInsurance
          : enableInsurance // ignore: cast_nullable_to_non_nullable
              as bool,
      enableAlarm: enableAlarm == freezed
          ? _value.enableAlarm
          : enableAlarm // ignore: cast_nullable_to_non_nullable
              as bool,
      tokenEarn: tokenEarn == freezed
          ? _value.tokenEarn
          : tokenEarn // ignore: cast_nullable_to_non_nullable
              as double,
      startTracking: startTracking == freezed
          ? _value.startTracking
          : startTracking // ignore: cast_nullable_to_non_nullable
              as bool,
      userStatusTracking: userStatusTracking == freezed
          ? _value.userStatusTracking
          : userStatusTracking // ignore: cast_nullable_to_non_nullable
              as UserStatusTrackingModel?,
      hour: hour == freezed
          ? _value.hour
          : hour // ignore: cast_nullable_to_non_nullable
              as int,
      minute: minute == freezed
          ? _value.minute
          : minute // ignore: cast_nullable_to_non_nullable
              as int,
      time: time == freezed
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }

  @override
  $BedEntityCopyWith<$Res>? get selectedBed {
    if (_value.selectedBed == null) {
      return null;
    }

    return $BedEntityCopyWith<$Res>(_value.selectedBed!, (value) {
      return _then(_value.copyWith(selectedBed: value));
    });
  }

  @override
  $BedEntityCopyWith<$Res>? get item {
    if (_value.item == null) {
      return null;
    }

    return $BedEntityCopyWith<$Res>(_value.item!, (value) {
      return _then(_value.copyWith(item: value));
    });
  }

  @override
  $ItemEntityCopyWith<$Res>? get selectedItem {
    if (_value.selectedItem == null) {
      return null;
    }

    return $ItemEntityCopyWith<$Res>(_value.selectedItem!, (value) {
      return _then(_value.copyWith(selectedItem: value));
    });
  }
}

/// @nodoc

class _$HomeLoaded with DiagnosticableTreeMixin implements HomeLoaded {
  const _$HomeLoaded(
      {required final List<BedEntity> bedList,
      required this.selectedBed,
      this.item,
      this.selectedItem,
      this.errorMessage = '',
      this.errorType = ErrorType.none,
      this.loadMoreBed = true,
      this.loading = false,
      this.enableInsurance = true,
      this.enableAlarm = true,
      this.tokenEarn = 0.0,
      this.startTracking = false,
      this.userStatusTracking,
      required this.hour,
      required this.minute,
      this.time = 0})
      : _bedList = bedList;

  final List<BedEntity> _bedList;
  @override
  List<BedEntity> get bedList {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_bedList);
  }

  @override
  final BedEntity? selectedBed;
  @override
  final BedEntity? item;
  @override
  final ItemEntity? selectedItem;
  @override
  @JsonKey()
  final String errorMessage;
  @override
  @JsonKey()
  final ErrorType errorType;
  @override
  @JsonKey()
  final bool loadMoreBed;
  @override
  @JsonKey()
  final bool loading;
  @override
  @JsonKey()
  final bool enableInsurance;
  @override
  @JsonKey()
  final bool enableAlarm;
  @override
  @JsonKey()
  final double tokenEarn;
  @override
  @JsonKey()
  final bool startTracking;
  @override
  final UserStatusTrackingModel? userStatusTracking;
  @override
  final int hour;
  @override
  final int minute;
  @override
  @JsonKey()
  final int time;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.loaded(bedList: $bedList, selectedBed: $selectedBed, item: $item, selectedItem: $selectedItem, errorMessage: $errorMessage, errorType: $errorType, loadMoreBed: $loadMoreBed, loading: $loading, enableInsurance: $enableInsurance, enableAlarm: $enableAlarm, tokenEarn: $tokenEarn, startTracking: $startTracking, userStatusTracking: $userStatusTracking, hour: $hour, minute: $minute, time: $time)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'HomeState.loaded'))
      ..add(DiagnosticsProperty('bedList', bedList))
      ..add(DiagnosticsProperty('selectedBed', selectedBed))
      ..add(DiagnosticsProperty('item', item))
      ..add(DiagnosticsProperty('selectedItem', selectedItem))
      ..add(DiagnosticsProperty('errorMessage', errorMessage))
      ..add(DiagnosticsProperty('errorType', errorType))
      ..add(DiagnosticsProperty('loadMoreBed', loadMoreBed))
      ..add(DiagnosticsProperty('loading', loading))
      ..add(DiagnosticsProperty('enableInsurance', enableInsurance))
      ..add(DiagnosticsProperty('enableAlarm', enableAlarm))
      ..add(DiagnosticsProperty('tokenEarn', tokenEarn))
      ..add(DiagnosticsProperty('startTracking', startTracking))
      ..add(DiagnosticsProperty('userStatusTracking', userStatusTracking))
      ..add(DiagnosticsProperty('hour', hour))
      ..add(DiagnosticsProperty('minute', minute))
      ..add(DiagnosticsProperty('time', time));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HomeLoaded &&
            const DeepCollectionEquality().equals(other._bedList, _bedList) &&
            const DeepCollectionEquality()
                .equals(other.selectedBed, selectedBed) &&
            const DeepCollectionEquality().equals(other.item, item) &&
            const DeepCollectionEquality()
                .equals(other.selectedItem, selectedItem) &&
            const DeepCollectionEquality()
                .equals(other.errorMessage, errorMessage) &&
            const DeepCollectionEquality().equals(other.errorType, errorType) &&
            const DeepCollectionEquality()
                .equals(other.loadMoreBed, loadMoreBed) &&
            const DeepCollectionEquality().equals(other.loading, loading) &&
            const DeepCollectionEquality()
                .equals(other.enableInsurance, enableInsurance) &&
            const DeepCollectionEquality()
                .equals(other.enableAlarm, enableAlarm) &&
            const DeepCollectionEquality().equals(other.tokenEarn, tokenEarn) &&
            const DeepCollectionEquality()
                .equals(other.startTracking, startTracking) &&
            const DeepCollectionEquality()
                .equals(other.userStatusTracking, userStatusTracking) &&
            const DeepCollectionEquality().equals(other.hour, hour) &&
            const DeepCollectionEquality().equals(other.minute, minute) &&
            const DeepCollectionEquality().equals(other.time, time));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_bedList),
      const DeepCollectionEquality().hash(selectedBed),
      const DeepCollectionEquality().hash(item),
      const DeepCollectionEquality().hash(selectedItem),
      const DeepCollectionEquality().hash(errorMessage),
      const DeepCollectionEquality().hash(errorType),
      const DeepCollectionEquality().hash(loadMoreBed),
      const DeepCollectionEquality().hash(loading),
      const DeepCollectionEquality().hash(enableInsurance),
      const DeepCollectionEquality().hash(enableAlarm),
      const DeepCollectionEquality().hash(tokenEarn),
      const DeepCollectionEquality().hash(startTracking),
      const DeepCollectionEquality().hash(userStatusTracking),
      const DeepCollectionEquality().hash(hour),
      const DeepCollectionEquality().hash(minute),
      const DeepCollectionEquality().hash(time));

  @JsonKey(ignore: true)
  @override
  _$$HomeLoadedCopyWith<_$HomeLoaded> get copyWith =>
      __$$HomeLoadedCopyWithImpl<_$HomeLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)
        loaded,
    required TResult Function(String message) startError,
    required TResult Function(String message) error,
  }) {
    return loaded(
        bedList,
        selectedBed,
        item,
        selectedItem,
        errorMessage,
        errorType,
        loadMoreBed,
        this.loading,
        enableInsurance,
        enableAlarm,
        tokenEarn,
        startTracking,
        userStatusTracking,
        hour,
        minute,
        time);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)?
        loaded,
    TResult Function(String message)? startError,
    TResult Function(String message)? error,
  }) {
    return loaded?.call(
        bedList,
        selectedBed,
        item,
        selectedItem,
        errorMessage,
        errorType,
        loadMoreBed,
        this.loading,
        enableInsurance,
        enableAlarm,
        tokenEarn,
        startTracking,
        userStatusTracking,
        hour,
        minute,
        time);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)?
        loaded,
    TResult Function(String message)? startError,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(
          bedList,
          selectedBed,
          item,
          selectedItem,
          errorMessage,
          errorType,
          loadMoreBed,
          this.loading,
          enableInsurance,
          enableAlarm,
          tokenEarn,
          startTracking,
          userStatusTracking,
          hour,
          minute,
          time);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HomeInitial value) initial,
    required TResult Function(HomeLoading value) loading,
    required TResult Function(HomeLoaded value) loaded,
    required TResult Function(HomeStartError value) startError,
    required TResult Function(HomeError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(HomeInitial value)? initial,
    TResult Function(HomeLoading value)? loading,
    TResult Function(HomeLoaded value)? loaded,
    TResult Function(HomeStartError value)? startError,
    TResult Function(HomeError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HomeInitial value)? initial,
    TResult Function(HomeLoading value)? loading,
    TResult Function(HomeLoaded value)? loaded,
    TResult Function(HomeStartError value)? startError,
    TResult Function(HomeError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class HomeLoaded implements HomeState {
  const factory HomeLoaded(
      {required final List<BedEntity> bedList,
      required final BedEntity? selectedBed,
      final BedEntity? item,
      final ItemEntity? selectedItem,
      final String errorMessage,
      final ErrorType errorType,
      final bool loadMoreBed,
      final bool loading,
      final bool enableInsurance,
      final bool enableAlarm,
      final double tokenEarn,
      final bool startTracking,
      final UserStatusTrackingModel? userStatusTracking,
      required final int hour,
      required final int minute,
      final int time}) = _$HomeLoaded;

  List<BedEntity> get bedList;
  BedEntity? get selectedBed;
  BedEntity? get item;
  ItemEntity? get selectedItem;
  String get errorMessage;
  ErrorType get errorType;
  bool get loadMoreBed;
  bool get loading;
  bool get enableInsurance;
  bool get enableAlarm;
  double get tokenEarn;
  bool get startTracking;
  UserStatusTrackingModel? get userStatusTracking;
  int get hour;
  int get minute;
  int get time;
  @JsonKey(ignore: true)
  _$$HomeLoadedCopyWith<_$HomeLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$HomeStartErrorCopyWith<$Res> {
  factory _$$HomeStartErrorCopyWith(
          _$HomeStartError value, $Res Function(_$HomeStartError) then) =
      __$$HomeStartErrorCopyWithImpl<$Res>;
  $Res call({String message});
}

/// @nodoc
class __$$HomeStartErrorCopyWithImpl<$Res> extends _$HomeStateCopyWithImpl<$Res>
    implements _$$HomeStartErrorCopyWith<$Res> {
  __$$HomeStartErrorCopyWithImpl(
      _$HomeStartError _value, $Res Function(_$HomeStartError) _then)
      : super(_value, (v) => _then(v as _$HomeStartError));

  @override
  _$HomeStartError get _value => super._value as _$HomeStartError;

  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(_$HomeStartError(
      message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$HomeStartError with DiagnosticableTreeMixin implements HomeStartError {
  const _$HomeStartError(this.message);

  @override
  final String message;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.startError(message: $message)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'HomeState.startError'))
      ..add(DiagnosticsProperty('message', message));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HomeStartError &&
            const DeepCollectionEquality().equals(other.message, message));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(message));

  @JsonKey(ignore: true)
  @override
  _$$HomeStartErrorCopyWith<_$HomeStartError> get copyWith =>
      __$$HomeStartErrorCopyWithImpl<_$HomeStartError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)
        loaded,
    required TResult Function(String message) startError,
    required TResult Function(String message) error,
  }) {
    return startError(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)?
        loaded,
    TResult Function(String message)? startError,
    TResult Function(String message)? error,
  }) {
    return startError?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)?
        loaded,
    TResult Function(String message)? startError,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (startError != null) {
      return startError(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HomeInitial value) initial,
    required TResult Function(HomeLoading value) loading,
    required TResult Function(HomeLoaded value) loaded,
    required TResult Function(HomeStartError value) startError,
    required TResult Function(HomeError value) error,
  }) {
    return startError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(HomeInitial value)? initial,
    TResult Function(HomeLoading value)? loading,
    TResult Function(HomeLoaded value)? loaded,
    TResult Function(HomeStartError value)? startError,
    TResult Function(HomeError value)? error,
  }) {
    return startError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HomeInitial value)? initial,
    TResult Function(HomeLoading value)? loading,
    TResult Function(HomeLoaded value)? loaded,
    TResult Function(HomeStartError value)? startError,
    TResult Function(HomeError value)? error,
    required TResult orElse(),
  }) {
    if (startError != null) {
      return startError(this);
    }
    return orElse();
  }
}

abstract class HomeStartError implements HomeState {
  const factory HomeStartError(final String message) = _$HomeStartError;

  String get message;
  @JsonKey(ignore: true)
  _$$HomeStartErrorCopyWith<_$HomeStartError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$HomeErrorCopyWith<$Res> {
  factory _$$HomeErrorCopyWith(
          _$HomeError value, $Res Function(_$HomeError) then) =
      __$$HomeErrorCopyWithImpl<$Res>;
  $Res call({String message});
}

/// @nodoc
class __$$HomeErrorCopyWithImpl<$Res> extends _$HomeStateCopyWithImpl<$Res>
    implements _$$HomeErrorCopyWith<$Res> {
  __$$HomeErrorCopyWithImpl(
      _$HomeError _value, $Res Function(_$HomeError) _then)
      : super(_value, (v) => _then(v as _$HomeError));

  @override
  _$HomeError get _value => super._value as _$HomeError;

  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(_$HomeError(
      message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$HomeError with DiagnosticableTreeMixin implements HomeError {
  const _$HomeError(this.message);

  @override
  final String message;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.error(message: $message)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'HomeState.error'))
      ..add(DiagnosticsProperty('message', message));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HomeError &&
            const DeepCollectionEquality().equals(other.message, message));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(message));

  @JsonKey(ignore: true)
  @override
  _$$HomeErrorCopyWith<_$HomeError> get copyWith =>
      __$$HomeErrorCopyWithImpl<_$HomeError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)
        loaded,
    required TResult Function(String message) startError,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)?
        loaded,
    TResult Function(String message)? startError,
    TResult Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<BedEntity> bedList,
            BedEntity? selectedBed,
            BedEntity? item,
            ItemEntity? selectedItem,
            String errorMessage,
            ErrorType errorType,
            bool loadMoreBed,
            bool loading,
            bool enableInsurance,
            bool enableAlarm,
            double tokenEarn,
            bool startTracking,
            UserStatusTrackingModel? userStatusTracking,
            int hour,
            int minute,
            int time)?
        loaded,
    TResult Function(String message)? startError,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HomeInitial value) initial,
    required TResult Function(HomeLoading value) loading,
    required TResult Function(HomeLoaded value) loaded,
    required TResult Function(HomeStartError value) startError,
    required TResult Function(HomeError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(HomeInitial value)? initial,
    TResult Function(HomeLoading value)? loading,
    TResult Function(HomeLoaded value)? loaded,
    TResult Function(HomeStartError value)? startError,
    TResult Function(HomeError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HomeInitial value)? initial,
    TResult Function(HomeLoading value)? loading,
    TResult Function(HomeLoaded value)? loaded,
    TResult Function(HomeStartError value)? startError,
    TResult Function(HomeError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class HomeError implements HomeState {
  const factory HomeError(final String message) = _$HomeError;

  String get message;
  @JsonKey(ignore: true)
  _$$HomeErrorCopyWith<_$HomeError> get copyWith =>
      throw _privateConstructorUsedError;
}
