// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'staking_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$StakingState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() empty,
    required TResult Function() stakingSuccess,
    required TResult Function(StakingInfoResponse stakingInfoResponse)
        stakingInfoSuccess,
    required TResult Function() unStakingSuccess,
    required TResult Function() compoundSuccess,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StakingStateInitial value) initial,
    required TResult Function(StakingStateLoading value) loading,
    required TResult Function(StakingStateLoaded value) loaded,
    required TResult Function(StakingStateEmpty value) empty,
    required TResult Function(StakingStateStakingSuccess value) stakingSuccess,
    required TResult Function(StakingStateStakingInfoSuccess value)
        stakingInfoSuccess,
    required TResult Function(StakingStateUnStakingSuccess value)
        unStakingSuccess,
    required TResult Function(StakingStateCompoundSuccess value)
        compoundSuccess,
    required TResult Function(StakingStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StakingStateCopyWith<$Res> {
  factory $StakingStateCopyWith(
          StakingState value, $Res Function(StakingState) then) =
      _$StakingStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$StakingStateCopyWithImpl<$Res> implements $StakingStateCopyWith<$Res> {
  _$StakingStateCopyWithImpl(this._value, this._then);

  final StakingState _value;
  // ignore: unused_field
  final $Res Function(StakingState) _then;
}

/// @nodoc
abstract class _$$StakingStateInitialCopyWith<$Res> {
  factory _$$StakingStateInitialCopyWith(_$StakingStateInitial value,
          $Res Function(_$StakingStateInitial) then) =
      __$$StakingStateInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StakingStateInitialCopyWithImpl<$Res>
    extends _$StakingStateCopyWithImpl<$Res>
    implements _$$StakingStateInitialCopyWith<$Res> {
  __$$StakingStateInitialCopyWithImpl(
      _$StakingStateInitial _value, $Res Function(_$StakingStateInitial) _then)
      : super(_value, (v) => _then(v as _$StakingStateInitial));

  @override
  _$StakingStateInitial get _value => super._value as _$StakingStateInitial;
}

/// @nodoc

class _$StakingStateInitial implements StakingStateInitial {
  const _$StakingStateInitial();

  @override
  String toString() {
    return 'StakingState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StakingStateInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() empty,
    required TResult Function() stakingSuccess,
    required TResult Function(StakingInfoResponse stakingInfoResponse)
        stakingInfoSuccess,
    required TResult Function() unStakingSuccess,
    required TResult Function() compoundSuccess,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StakingStateInitial value) initial,
    required TResult Function(StakingStateLoading value) loading,
    required TResult Function(StakingStateLoaded value) loaded,
    required TResult Function(StakingStateEmpty value) empty,
    required TResult Function(StakingStateStakingSuccess value) stakingSuccess,
    required TResult Function(StakingStateStakingInfoSuccess value)
        stakingInfoSuccess,
    required TResult Function(StakingStateUnStakingSuccess value)
        unStakingSuccess,
    required TResult Function(StakingStateCompoundSuccess value)
        compoundSuccess,
    required TResult Function(StakingStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class StakingStateInitial implements StakingState {
  const factory StakingStateInitial() = _$StakingStateInitial;
}

/// @nodoc
abstract class _$$StakingStateLoadingCopyWith<$Res> {
  factory _$$StakingStateLoadingCopyWith(_$StakingStateLoading value,
          $Res Function(_$StakingStateLoading) then) =
      __$$StakingStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StakingStateLoadingCopyWithImpl<$Res>
    extends _$StakingStateCopyWithImpl<$Res>
    implements _$$StakingStateLoadingCopyWith<$Res> {
  __$$StakingStateLoadingCopyWithImpl(
      _$StakingStateLoading _value, $Res Function(_$StakingStateLoading) _then)
      : super(_value, (v) => _then(v as _$StakingStateLoading));

  @override
  _$StakingStateLoading get _value => super._value as _$StakingStateLoading;
}

/// @nodoc

class _$StakingStateLoading implements StakingStateLoading {
  const _$StakingStateLoading();

  @override
  String toString() {
    return 'StakingState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StakingStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() empty,
    required TResult Function() stakingSuccess,
    required TResult Function(StakingInfoResponse stakingInfoResponse)
        stakingInfoSuccess,
    required TResult Function() unStakingSuccess,
    required TResult Function() compoundSuccess,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StakingStateInitial value) initial,
    required TResult Function(StakingStateLoading value) loading,
    required TResult Function(StakingStateLoaded value) loaded,
    required TResult Function(StakingStateEmpty value) empty,
    required TResult Function(StakingStateStakingSuccess value) stakingSuccess,
    required TResult Function(StakingStateStakingInfoSuccess value)
        stakingInfoSuccess,
    required TResult Function(StakingStateUnStakingSuccess value)
        unStakingSuccess,
    required TResult Function(StakingStateCompoundSuccess value)
        compoundSuccess,
    required TResult Function(StakingStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class StakingStateLoading implements StakingState {
  const factory StakingStateLoading() = _$StakingStateLoading;
}

/// @nodoc
abstract class _$$StakingStateLoadedCopyWith<$Res> {
  factory _$$StakingStateLoadedCopyWith(_$StakingStateLoaded value,
          $Res Function(_$StakingStateLoaded) then) =
      __$$StakingStateLoadedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StakingStateLoadedCopyWithImpl<$Res>
    extends _$StakingStateCopyWithImpl<$Res>
    implements _$$StakingStateLoadedCopyWith<$Res> {
  __$$StakingStateLoadedCopyWithImpl(
      _$StakingStateLoaded _value, $Res Function(_$StakingStateLoaded) _then)
      : super(_value, (v) => _then(v as _$StakingStateLoaded));

  @override
  _$StakingStateLoaded get _value => super._value as _$StakingStateLoaded;
}

/// @nodoc

class _$StakingStateLoaded implements StakingStateLoaded {
  const _$StakingStateLoaded();

  @override
  String toString() {
    return 'StakingState.loaded()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StakingStateLoaded);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() empty,
    required TResult Function() stakingSuccess,
    required TResult Function(StakingInfoResponse stakingInfoResponse)
        stakingInfoSuccess,
    required TResult Function() unStakingSuccess,
    required TResult Function() compoundSuccess,
    required TResult Function(String message) error,
  }) {
    return loaded();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
  }) {
    return loaded?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StakingStateInitial value) initial,
    required TResult Function(StakingStateLoading value) loading,
    required TResult Function(StakingStateLoaded value) loaded,
    required TResult Function(StakingStateEmpty value) empty,
    required TResult Function(StakingStateStakingSuccess value) stakingSuccess,
    required TResult Function(StakingStateStakingInfoSuccess value)
        stakingInfoSuccess,
    required TResult Function(StakingStateUnStakingSuccess value)
        unStakingSuccess,
    required TResult Function(StakingStateCompoundSuccess value)
        compoundSuccess,
    required TResult Function(StakingStateError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class StakingStateLoaded implements StakingState {
  const factory StakingStateLoaded() = _$StakingStateLoaded;
}

/// @nodoc
abstract class _$$StakingStateEmptyCopyWith<$Res> {
  factory _$$StakingStateEmptyCopyWith(
          _$StakingStateEmpty value, $Res Function(_$StakingStateEmpty) then) =
      __$$StakingStateEmptyCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StakingStateEmptyCopyWithImpl<$Res>
    extends _$StakingStateCopyWithImpl<$Res>
    implements _$$StakingStateEmptyCopyWith<$Res> {
  __$$StakingStateEmptyCopyWithImpl(
      _$StakingStateEmpty _value, $Res Function(_$StakingStateEmpty) _then)
      : super(_value, (v) => _then(v as _$StakingStateEmpty));

  @override
  _$StakingStateEmpty get _value => super._value as _$StakingStateEmpty;
}

/// @nodoc

class _$StakingStateEmpty implements StakingStateEmpty {
  const _$StakingStateEmpty();

  @override
  String toString() {
    return 'StakingState.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StakingStateEmpty);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() empty,
    required TResult Function() stakingSuccess,
    required TResult Function(StakingInfoResponse stakingInfoResponse)
        stakingInfoSuccess,
    required TResult Function() unStakingSuccess,
    required TResult Function() compoundSuccess,
    required TResult Function(String message) error,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StakingStateInitial value) initial,
    required TResult Function(StakingStateLoading value) loading,
    required TResult Function(StakingStateLoaded value) loaded,
    required TResult Function(StakingStateEmpty value) empty,
    required TResult Function(StakingStateStakingSuccess value) stakingSuccess,
    required TResult Function(StakingStateStakingInfoSuccess value)
        stakingInfoSuccess,
    required TResult Function(StakingStateUnStakingSuccess value)
        unStakingSuccess,
    required TResult Function(StakingStateCompoundSuccess value)
        compoundSuccess,
    required TResult Function(StakingStateError value) error,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class StakingStateEmpty implements StakingState {
  const factory StakingStateEmpty() = _$StakingStateEmpty;
}

/// @nodoc
abstract class _$$StakingStateStakingSuccessCopyWith<$Res> {
  factory _$$StakingStateStakingSuccessCopyWith(
          _$StakingStateStakingSuccess value,
          $Res Function(_$StakingStateStakingSuccess) then) =
      __$$StakingStateStakingSuccessCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StakingStateStakingSuccessCopyWithImpl<$Res>
    extends _$StakingStateCopyWithImpl<$Res>
    implements _$$StakingStateStakingSuccessCopyWith<$Res> {
  __$$StakingStateStakingSuccessCopyWithImpl(
      _$StakingStateStakingSuccess _value,
      $Res Function(_$StakingStateStakingSuccess) _then)
      : super(_value, (v) => _then(v as _$StakingStateStakingSuccess));

  @override
  _$StakingStateStakingSuccess get _value =>
      super._value as _$StakingStateStakingSuccess;
}

/// @nodoc

class _$StakingStateStakingSuccess implements StakingStateStakingSuccess {
  const _$StakingStateStakingSuccess();

  @override
  String toString() {
    return 'StakingState.stakingSuccess()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StakingStateStakingSuccess);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() empty,
    required TResult Function() stakingSuccess,
    required TResult Function(StakingInfoResponse stakingInfoResponse)
        stakingInfoSuccess,
    required TResult Function() unStakingSuccess,
    required TResult Function() compoundSuccess,
    required TResult Function(String message) error,
  }) {
    return stakingSuccess();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
  }) {
    return stakingSuccess?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (stakingSuccess != null) {
      return stakingSuccess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StakingStateInitial value) initial,
    required TResult Function(StakingStateLoading value) loading,
    required TResult Function(StakingStateLoaded value) loaded,
    required TResult Function(StakingStateEmpty value) empty,
    required TResult Function(StakingStateStakingSuccess value) stakingSuccess,
    required TResult Function(StakingStateStakingInfoSuccess value)
        stakingInfoSuccess,
    required TResult Function(StakingStateUnStakingSuccess value)
        unStakingSuccess,
    required TResult Function(StakingStateCompoundSuccess value)
        compoundSuccess,
    required TResult Function(StakingStateError value) error,
  }) {
    return stakingSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
  }) {
    return stakingSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
    required TResult orElse(),
  }) {
    if (stakingSuccess != null) {
      return stakingSuccess(this);
    }
    return orElse();
  }
}

abstract class StakingStateStakingSuccess implements StakingState {
  const factory StakingStateStakingSuccess() = _$StakingStateStakingSuccess;
}

/// @nodoc
abstract class _$$StakingStateStakingInfoSuccessCopyWith<$Res> {
  factory _$$StakingStateStakingInfoSuccessCopyWith(
          _$StakingStateStakingInfoSuccess value,
          $Res Function(_$StakingStateStakingInfoSuccess) then) =
      __$$StakingStateStakingInfoSuccessCopyWithImpl<$Res>;
  $Res call({StakingInfoResponse stakingInfoResponse});
}

/// @nodoc
class __$$StakingStateStakingInfoSuccessCopyWithImpl<$Res>
    extends _$StakingStateCopyWithImpl<$Res>
    implements _$$StakingStateStakingInfoSuccessCopyWith<$Res> {
  __$$StakingStateStakingInfoSuccessCopyWithImpl(
      _$StakingStateStakingInfoSuccess _value,
      $Res Function(_$StakingStateStakingInfoSuccess) _then)
      : super(_value, (v) => _then(v as _$StakingStateStakingInfoSuccess));

  @override
  _$StakingStateStakingInfoSuccess get _value =>
      super._value as _$StakingStateStakingInfoSuccess;

  @override
  $Res call({
    Object? stakingInfoResponse = freezed,
  }) {
    return _then(_$StakingStateStakingInfoSuccess(
      stakingInfoResponse == freezed
          ? _value.stakingInfoResponse
          : stakingInfoResponse // ignore: cast_nullable_to_non_nullable
              as StakingInfoResponse,
    ));
  }
}

/// @nodoc

class _$StakingStateStakingInfoSuccess
    implements StakingStateStakingInfoSuccess {
  const _$StakingStateStakingInfoSuccess(this.stakingInfoResponse);

  @override
  final StakingInfoResponse stakingInfoResponse;

  @override
  String toString() {
    return 'StakingState.stakingInfoSuccess(stakingInfoResponse: $stakingInfoResponse)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StakingStateStakingInfoSuccess &&
            const DeepCollectionEquality()
                .equals(other.stakingInfoResponse, stakingInfoResponse));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(stakingInfoResponse));

  @JsonKey(ignore: true)
  @override
  _$$StakingStateStakingInfoSuccessCopyWith<_$StakingStateStakingInfoSuccess>
      get copyWith => __$$StakingStateStakingInfoSuccessCopyWithImpl<
          _$StakingStateStakingInfoSuccess>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() empty,
    required TResult Function() stakingSuccess,
    required TResult Function(StakingInfoResponse stakingInfoResponse)
        stakingInfoSuccess,
    required TResult Function() unStakingSuccess,
    required TResult Function() compoundSuccess,
    required TResult Function(String message) error,
  }) {
    return stakingInfoSuccess(stakingInfoResponse);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
  }) {
    return stakingInfoSuccess?.call(stakingInfoResponse);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (stakingInfoSuccess != null) {
      return stakingInfoSuccess(stakingInfoResponse);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StakingStateInitial value) initial,
    required TResult Function(StakingStateLoading value) loading,
    required TResult Function(StakingStateLoaded value) loaded,
    required TResult Function(StakingStateEmpty value) empty,
    required TResult Function(StakingStateStakingSuccess value) stakingSuccess,
    required TResult Function(StakingStateStakingInfoSuccess value)
        stakingInfoSuccess,
    required TResult Function(StakingStateUnStakingSuccess value)
        unStakingSuccess,
    required TResult Function(StakingStateCompoundSuccess value)
        compoundSuccess,
    required TResult Function(StakingStateError value) error,
  }) {
    return stakingInfoSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
  }) {
    return stakingInfoSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
    required TResult orElse(),
  }) {
    if (stakingInfoSuccess != null) {
      return stakingInfoSuccess(this);
    }
    return orElse();
  }
}

abstract class StakingStateStakingInfoSuccess implements StakingState {
  const factory StakingStateStakingInfoSuccess(
          final StakingInfoResponse stakingInfoResponse) =
      _$StakingStateStakingInfoSuccess;

  StakingInfoResponse get stakingInfoResponse;
  @JsonKey(ignore: true)
  _$$StakingStateStakingInfoSuccessCopyWith<_$StakingStateStakingInfoSuccess>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$StakingStateUnStakingSuccessCopyWith<$Res> {
  factory _$$StakingStateUnStakingSuccessCopyWith(
          _$StakingStateUnStakingSuccess value,
          $Res Function(_$StakingStateUnStakingSuccess) then) =
      __$$StakingStateUnStakingSuccessCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StakingStateUnStakingSuccessCopyWithImpl<$Res>
    extends _$StakingStateCopyWithImpl<$Res>
    implements _$$StakingStateUnStakingSuccessCopyWith<$Res> {
  __$$StakingStateUnStakingSuccessCopyWithImpl(
      _$StakingStateUnStakingSuccess _value,
      $Res Function(_$StakingStateUnStakingSuccess) _then)
      : super(_value, (v) => _then(v as _$StakingStateUnStakingSuccess));

  @override
  _$StakingStateUnStakingSuccess get _value =>
      super._value as _$StakingStateUnStakingSuccess;
}

/// @nodoc

class _$StakingStateUnStakingSuccess implements StakingStateUnStakingSuccess {
  const _$StakingStateUnStakingSuccess();

  @override
  String toString() {
    return 'StakingState.unStakingSuccess()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StakingStateUnStakingSuccess);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() empty,
    required TResult Function() stakingSuccess,
    required TResult Function(StakingInfoResponse stakingInfoResponse)
        stakingInfoSuccess,
    required TResult Function() unStakingSuccess,
    required TResult Function() compoundSuccess,
    required TResult Function(String message) error,
  }) {
    return unStakingSuccess();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
  }) {
    return unStakingSuccess?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (unStakingSuccess != null) {
      return unStakingSuccess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StakingStateInitial value) initial,
    required TResult Function(StakingStateLoading value) loading,
    required TResult Function(StakingStateLoaded value) loaded,
    required TResult Function(StakingStateEmpty value) empty,
    required TResult Function(StakingStateStakingSuccess value) stakingSuccess,
    required TResult Function(StakingStateStakingInfoSuccess value)
        stakingInfoSuccess,
    required TResult Function(StakingStateUnStakingSuccess value)
        unStakingSuccess,
    required TResult Function(StakingStateCompoundSuccess value)
        compoundSuccess,
    required TResult Function(StakingStateError value) error,
  }) {
    return unStakingSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
  }) {
    return unStakingSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
    required TResult orElse(),
  }) {
    if (unStakingSuccess != null) {
      return unStakingSuccess(this);
    }
    return orElse();
  }
}

abstract class StakingStateUnStakingSuccess implements StakingState {
  const factory StakingStateUnStakingSuccess() = _$StakingStateUnStakingSuccess;
}

/// @nodoc
abstract class _$$StakingStateCompoundSuccessCopyWith<$Res> {
  factory _$$StakingStateCompoundSuccessCopyWith(
          _$StakingStateCompoundSuccess value,
          $Res Function(_$StakingStateCompoundSuccess) then) =
      __$$StakingStateCompoundSuccessCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StakingStateCompoundSuccessCopyWithImpl<$Res>
    extends _$StakingStateCopyWithImpl<$Res>
    implements _$$StakingStateCompoundSuccessCopyWith<$Res> {
  __$$StakingStateCompoundSuccessCopyWithImpl(
      _$StakingStateCompoundSuccess _value,
      $Res Function(_$StakingStateCompoundSuccess) _then)
      : super(_value, (v) => _then(v as _$StakingStateCompoundSuccess));

  @override
  _$StakingStateCompoundSuccess get _value =>
      super._value as _$StakingStateCompoundSuccess;
}

/// @nodoc

class _$StakingStateCompoundSuccess implements StakingStateCompoundSuccess {
  const _$StakingStateCompoundSuccess();

  @override
  String toString() {
    return 'StakingState.compoundSuccess()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StakingStateCompoundSuccess);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() empty,
    required TResult Function() stakingSuccess,
    required TResult Function(StakingInfoResponse stakingInfoResponse)
        stakingInfoSuccess,
    required TResult Function() unStakingSuccess,
    required TResult Function() compoundSuccess,
    required TResult Function(String message) error,
  }) {
    return compoundSuccess();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
  }) {
    return compoundSuccess?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (compoundSuccess != null) {
      return compoundSuccess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StakingStateInitial value) initial,
    required TResult Function(StakingStateLoading value) loading,
    required TResult Function(StakingStateLoaded value) loaded,
    required TResult Function(StakingStateEmpty value) empty,
    required TResult Function(StakingStateStakingSuccess value) stakingSuccess,
    required TResult Function(StakingStateStakingInfoSuccess value)
        stakingInfoSuccess,
    required TResult Function(StakingStateUnStakingSuccess value)
        unStakingSuccess,
    required TResult Function(StakingStateCompoundSuccess value)
        compoundSuccess,
    required TResult Function(StakingStateError value) error,
  }) {
    return compoundSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
  }) {
    return compoundSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
    required TResult orElse(),
  }) {
    if (compoundSuccess != null) {
      return compoundSuccess(this);
    }
    return orElse();
  }
}

abstract class StakingStateCompoundSuccess implements StakingState {
  const factory StakingStateCompoundSuccess() = _$StakingStateCompoundSuccess;
}

/// @nodoc
abstract class _$$StakingStateErrorCopyWith<$Res> {
  factory _$$StakingStateErrorCopyWith(
          _$StakingStateError value, $Res Function(_$StakingStateError) then) =
      __$$StakingStateErrorCopyWithImpl<$Res>;
  $Res call({String message});
}

/// @nodoc
class __$$StakingStateErrorCopyWithImpl<$Res>
    extends _$StakingStateCopyWithImpl<$Res>
    implements _$$StakingStateErrorCopyWith<$Res> {
  __$$StakingStateErrorCopyWithImpl(
      _$StakingStateError _value, $Res Function(_$StakingStateError) _then)
      : super(_value, (v) => _then(v as _$StakingStateError));

  @override
  _$StakingStateError get _value => super._value as _$StakingStateError;

  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(_$StakingStateError(
      message: message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$StakingStateError implements StakingStateError {
  const _$StakingStateError({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'StakingState.error(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StakingStateError &&
            const DeepCollectionEquality().equals(other.message, message));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(message));

  @JsonKey(ignore: true)
  @override
  _$$StakingStateErrorCopyWith<_$StakingStateError> get copyWith =>
      __$$StakingStateErrorCopyWithImpl<_$StakingStateError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() empty,
    required TResult Function() stakingSuccess,
    required TResult Function(StakingInfoResponse stakingInfoResponse)
        stakingInfoSuccess,
    required TResult Function() unStakingSuccess,
    required TResult Function() compoundSuccess,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? empty,
    TResult Function()? stakingSuccess,
    TResult Function(StakingInfoResponse stakingInfoResponse)?
        stakingInfoSuccess,
    TResult Function()? unStakingSuccess,
    TResult Function()? compoundSuccess,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StakingStateInitial value) initial,
    required TResult Function(StakingStateLoading value) loading,
    required TResult Function(StakingStateLoaded value) loaded,
    required TResult Function(StakingStateEmpty value) empty,
    required TResult Function(StakingStateStakingSuccess value) stakingSuccess,
    required TResult Function(StakingStateStakingInfoSuccess value)
        stakingInfoSuccess,
    required TResult Function(StakingStateUnStakingSuccess value)
        unStakingSuccess,
    required TResult Function(StakingStateCompoundSuccess value)
        compoundSuccess,
    required TResult Function(StakingStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StakingStateInitial value)? initial,
    TResult Function(StakingStateLoading value)? loading,
    TResult Function(StakingStateLoaded value)? loaded,
    TResult Function(StakingStateEmpty value)? empty,
    TResult Function(StakingStateStakingSuccess value)? stakingSuccess,
    TResult Function(StakingStateStakingInfoSuccess value)? stakingInfoSuccess,
    TResult Function(StakingStateUnStakingSuccess value)? unStakingSuccess,
    TResult Function(StakingStateCompoundSuccess value)? compoundSuccess,
    TResult Function(StakingStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class StakingStateError implements StakingState {
  const factory StakingStateError({required final String message}) =
      _$StakingStateError;

  String get message;
  @JsonKey(ignore: true)
  _$$StakingStateErrorCopyWith<_$StakingStateError> get copyWith =>
      throw _privateConstructorUsedError;
}
